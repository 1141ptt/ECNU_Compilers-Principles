# 安全编程整理

## ch0 概述

当发送方向接收方发送数据时，需要考虑：数据的安全性、完整性、真实性、不可否认性。

对称加密：**加解密使用相同的密钥**。常见的算法如**DES、AES**。优点是**计算速度快**，缺点在于密钥的**安全**传输问题。

公钥加密：加密密钥公开，解密密钥私有，发送者使用公钥加密，接收者使用私钥解密。常见的算法如**RSA、椭圆曲线算法**。优点是**解决了密钥安全性问题**，缺点在于**计算速度慢和无法保证公钥合法性**。

消息摘要：是一种用于判断**数据完整性**的算法，该算法**不可逆**。常见的算法如**MD5**、**SHA**。优点是**保证了数据完整性**，缺点是**无法保证数据的真实性**。

消息认证码：一种可以确认消息完整性并进行认证的技术。是一种与密钥相关的**单向散列函数**。优点是**保证了数据的完整性和真实性**，缺点在于**不能防止发送方否认发送消息**。

数字签名：用于解决发送方否认发送过消息的问题。缺点在于仍然没有解决确保公钥合法性的问题。解决办法是将公钥交给一个第三方权威机构——认证机构（Certification Authority）CA来管理。接收方将自己的公钥注册到CA，由CA提供数字签名生成公钥证书。

## ch1 大素数生成

### 强拟素数

设$n>1$为奇合数，$b∈Z$，$(b,n)=1$，令$n= 2^st+1$，其中$t$为奇数，若$b^t≡1\ (mod\ n)$或存在$r∈Z$，$0≤r<s$，使得$b^{2^rt}≡−1\ (mod\ n)$，则$n$称为对于基$b$的强拟素数。

$2047 = 23 \cdot 89$是对于基2的强拟素数。事实上，$2047 − 1 = 2 \cdot 1023$，而$2^{1023} = (2^{11})^{93}≡1^{93}=1\ (mod\ 2047)$，因此2047是对于基2的强拟素数。

两个定理：存在**无穷多个**对于**基2**的强拟素数。设$n$是奇合数，$b\in Z$，$1\le b<n$，那么$n$是对于基$b$的强拟素数的概率不超过$\frac{1}{4}$。

### Miller-Rabin素性检验

给定正奇数$n$和参数$t\in Z^+$，令$n=2^sk+1$，其中$k$为正奇数，

（i）若已选过$t$个$b$，则判断$n$是素数，算法终止；
（ii）随机选取整数$b$，$2\le b\le n-2$，令$n=0$，计算$r_i=b^k\ (mod\ n)$，如果$r_i=1$或$n-1$，则返回至（i）；
（iii）若$i<s-1$，令$i=i+1$，计算$r_i=r_{i-1}^2\ (mod\ n)$，如果$r_i=n-1$，则返回至（i）；
（iv）判断$n$是合数，算法终止。

其中误判n是素数的概率不超过$\frac{1}{4^t}$。

## ch2 流密码

为了防止密钥穷举，使用和明文信息一样长的密钥流$z=z_1z_2\dots$进行加密。
$$
y=y_1y_2\dots=e_{z_1}(x_1)e_{z_2}(x_2)\dots
$$
代表：弗纳姆（Vernam）密码，关键在于**构造和消息一样长的随机密钥**

特点：**运算简单**；**实时性强**；**一次一密**；**安全性依赖于密钥流的产生**

分类：按周期性分为**周期流密码和非周期流密码**；按密钥的产生方式分为**同步流密码和非周期性密码**（网上写的是**自同步流密码**）。

### 同步流密码

使用某种算法，**由一个初始密钥变幻出和明文串相互独立的密钥流**，定义如下：同步流密码是一个六元组$(P,C,K,L,E,D)$和一个函数$g$，且满足如下条件：
（1）$P,C,K$分别是明文、密文、密钥的有限集。
（2）$L$是密钥流字母表有限集。
（3）$g$是密钥流生成器，$g$使用密钥$k\in K$作为输入，产生无限长的密钥流$z=z_1z_2\dots$，其中$z_i\in L$。
（4）对任意的$z\in L$，都有一个加密规则（函数）$e_z:P\to C\in E$和相应的解密规则（函数）$d_z:C\to P\in D$，并且对每个明文$x\in P$满足$d_z(e_z(x))=x$。

可用线性递推关系产生伪随机序列。设$(a_1,a_2,a_3,a_4)$为(0,0,0,1)密钥流按照递推关系$a_{i+4}=(a_i+a_{i+3})\ mod\ 2$产生线性关系：000111101011001 000111101011001…，周期为15，$(a_1,a_2,a_3,a_4)$称为初始向量。

上述方法可通过**线性反馈移位寄存器**（LFSR）实现。

一个n级LFSR能产生m序列的充要条件是它的**特征多项式为一个n次本原多项式**。m序列指输出序列的周期最大为$2^n-1$，$f(x)=c_0+c_1x+c_2x^2+\dots+c_nx^n$是特征多项式。

本原多项式：若一个n次多项式$f(x)$的阶为$2^n-1$，即满足条件：
（1）f(x)为既约多项式
（2）f(x)可整除$(x^{2n-1}+1)$
（3）f(x)不可整除$(x^p+1)$，其中$p<2^n-1$

n级的LFSR可以产生$\lambda(n)*(2^n-1)$种密钥流。

### 异步流密码

密钥流z的产生不但与密钥k有关，还与明文元素或密文元素有关。**异步**流密码存在**周期问题**。

自动密钥密码：通过K和明文产生密钥流。

例：自动密钥密码是一个六元组$(P,C,K,L,E,D)$，且满足如下条件：
（1）$P=C=K=L=Z_{26}$
（2）密钥流定义：$z_1=k\in K$，$z_i=x_{i-1},i\ge 2$
（3）对任意的$z\in K$，$x,y\in Z_{26}$，定义$e_z(x)=(x+z)\ mod\ 26$；$d_z(y)=(y-z)\ mod\ 26$

设$k=8$，明文为`rendezvous`，加密过程如下：

首先将明文转换为整数序列（按照‘a’~‘z’对应‘0’~‘25’）：17   4   13   3   4   25   21   14   20   18
根据$z_1=k=8,z_i=x_{i-1}$得到密钥流为（首位是8，然后接上一行）：8   17   4   13   3   4   25   21   14   20
将对应的元素相加并模26得到（相邻元素相加模26）：25   21   17   16   7   3   20   9   8   12

字母形式的密文为（按照‘0’~‘25’对应‘a’~‘z’）：`ZVRQHDUJIM`

## ch3 DES加密算法

### 简介

分组长度为64 bits（8 bytes）。

密文分组长度也是64 bits。

密钥长度为64 bits，有8 bits奇偶校验，**有效密钥长度为56 bits**。

算法主要包括：初始置换IP、16轮迭代的乘积变换、逆初始置换$IP^{-1}$以及16个子密钥产生器。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611162556570.png" alt="image-20210611162556570" style="zoom:80%;" />

初始置换：将64 bits明文的位置进行置换，得到一个乱序的64 bit明文组。

逆初始置换：将16轮迭代后给出的64 bit组进行置换，得到输出的密文组。输出为阵中元素按行读得的结果。

作用：**打乱原来输出x的ASCII码字划分的关系**。

DES轮函数：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163556925.png" alt="image-20210611163556925" style="zoom:67%;" />

设输入为$(x,y)$，则DES的轮函数输出为：$(y,x\oplus f_k(y))$

它**等价于两个对合变换的复合**：$(x,y)\mapsto(x\oplus f(k,y),y)\mapsto(y,x\oplus f(k,y))$

无论f函数如何选取，DES的轮函数是一个**对合变换**。
$$
F(x,y)=(x\oplus f(k,y),y)\\F(F(x,y))=F(x\oplus f(k,y),y)=((x\oplus f(k,y))\oplus f(k,y),y)=(x,y)
$$
$f(R,K)$计算过程：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163656340.png" alt="image-20210611163656340" style="zoom:80%;" />

选择扩展运算E：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163723059.png" alt="image-20210611163723059" style="zoom:60%;" />

选择压缩运算S：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163744195.png" alt="image-20210611163744195" style="zoom:60%;" />

DES的S盒：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163802887.png" alt="image-20210611163802887" style="zoom:67%;" />

DES的S盒输入输出关系：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163821646.png" alt="image-20210611163821646" style="zoom:67%;" />

**将S-盒变换后的32比特数据再进行P盒置换，置换后得到的32比特即为f函数的输出**。

P盒置换的基本特点：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611163943073.png" alt="image-20210611163943073" style="zoom:67%;" /> 

（1）P盒的各**输出块的4个比特**都来自**不同的输入块**；

（2）P盒的各**输入块的4个比特**都分配到**不同的输出块**之中；

（2）P盒的**第t个输出块的4个比特**都**不来自第t各输入块**。

含义：P盒输出的第1个元是输入的第16个元。

DES密钥编排：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611164244709.png" alt="image-20210611164244709" style="zoom:67%;" />

子密钥的生成：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611164312275.png" alt="image-20210611164312275" style="zoom:67%;" />

### DES安全性

DES的弱密钥：DES密钥的互补性，若**明文组x逐位取补，密钥k逐位取补**，即$y=DES_k(x)$，则有$\overline{y}=DES_k(\overline{x})$，该性质会使DES在选择明文破译下所需工作量减半。

在同一密钥下加密两次为恒等变换，DES存在4个弱密钥。

密钥对$K_1$和$K_2$互不相同，用$K_1$加密的密文可以用$K_2$解密，至少有12个半弱密钥。

DES在每次迭代时都有一个子密钥供加密用。如果给定初始密钥k，各轮的子密钥相同，既有$k_1=k_2=\dots=k_{16}$，就称给定的密钥k为弱密钥。

DES密钥长度的争论：目前攻击DES的方法有时间-空间权衡攻击、差分攻击、线性攻击和相关密钥攻击等方法，其中**线性攻击**是最有效的一种方法。

### 3DES加密算法

多重DES是使用多个密钥利用DES对明文进行多次加密。使用多重DES可**增加密钥量**，**提高抵抗穷举密钥搜索攻击的能力**。

双重DES：对消息$x_i$利用两个不同密钥进行两次加密，目的是为了抵抗穷举搜索攻击，期望密钥长度扩展为112比特。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611190059858.png" alt="image-20210611190059858" style="zoom:50%;" />

中间相遇攻击：若有明文/密文对满足：$y_i=E_{k_2}[E_{k_1}(x_i)]$，则可得：$z=E_{k_1}(x_i)=D_{k_2}(y_i)$，可以降低搜索量。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611190305863.png" alt="image-20210611190305863" style="zoom:50%;" />

攻击步骤：

给定一已知明密文$(x_1,y_1)$，可按下述方法攻击：
（1）以密钥$k_1$的所有$2^{56}$个可能的取值对此明文$x_1$加密，并将密文$z$存储在一个表中；
（2）从所有可能的$2^{56}$个密钥$k_2$中以任意次序选出一个对给定的密文$y_1$进行解密，并将每次解密结果$z$在上述表中查找相匹配的值。一旦找到，则可确定出两个密钥$k_1$和$k_2$； 
（3）以此对密钥$k_1$和$k_2$对另一已知明文密文对$(x_2,y_2)$中的$x_2$进行加密，如果能得出相应的密文$y_2$就可以确定$k_1$和$k_2$是所要找的密钥。

攻击复杂度：$2^{57}$

三重DES：三重DES中的三个密码组件既可以是一个加密函数，也可以是一个解密函数。当$k_1=k_3$时，称为双密钥三重DES。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611190658831.png" alt="image-20210611190658831" style="zoom:50%;" />

加密：$y=E_{k_1}[D_{k_2}[E_{k_1}(x)]]$；解密：$x=D_{k_1}[E_{k_2}[D_{k_1}(y)]]$，称为加密-解密-加密方案，简记为EDE。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611190848191.png" alt="image-20210611190848191" style="zoom:50%;" />

安全性：

（1）破译三重DES穷举密钥搜索量为$2^{112}$量级
（2）差分攻击破译也要超过$10^{52}$量级
（3）此方案仍有足够的安全性

## ch4 AES加密算法

### 简介

与Rijndael算法不同之处：

- AES分组**固定长度128位**，**密钥长度是128、192或256位**；
- Rijndael算法分组长度可以是128、160、192、224或256位

轮函数：

（1）线性混合层：确保多轮之上的高度扩散；
（2）非线性层：将具有最优的“最坏情况非线性特性”的S盒并行使用；
（3）密钥加层：单轮子密钥简单的异或到中间状态上，实现一次性的掩盖。

算法说明：

（1）**明文分组可变**，128、192、256比特。
（2）**密钥长度可变**，各自可独立指定为128、192、256比特。
（3）状态。算法中间的结果也需要分组，称之为状态，状态可用以字节为元素的矩阵阵列表示，该阵列有4行，列数$N_b$为分组长度除以32.
（4）种子密钥。以字节为元素的矩阵阵列描述，阵列为4行，列数$N_k$为密钥长度除以32。
（5）算法的输入、输出盒种子密钥可看成字节组成的一维数组。
（6）下标范围。输入输出：$0\sim4N_b-1$；种子密钥$0\sim4N_k-1$。

$N_B=6$和$N_k=4$的状态密钥阵列：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611193615733.png" alt="image-20210611193615733" style="zoom:70%;" />

分组和阵列中元素对应关系：

分组下标$n$和阵列位置$(i,j)$，$i=n\ mod\ 4$，$j=[n/4]$；$n=i+4j$

轮数$N_r$与$N_b$和$N_k$对应关系如下表所示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611193820352.png" alt="image-20210611193820352" style="zoom:50%;" />

**10轮AES加解密过程**：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611193842771.png" alt="image-20210611193842771" style="zoom:67%;" />

### 算法流程

#### 字节代换

非线性代换，独立地对状态的每个字节进行，并且**S盒可逆**，分两步：

（1）将输入的字节作为$GF(2^8)$上的元素**映射到自己的逆元**（生成多项式：$x^8+x^4+x^3+x+1$）
（2）将该逆元字节做$GF(2)$上的**仿射变换**，即$y=Ax^{-1}+B$，其中$A$是$GF(2)$上的一个$8\times 8$的可逆矩阵，$B$是$GF(2)$上的一个8位列向量。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611194318191.png" alt="image-20210611194318191" style="zoom:67%;" />

S盒的使用：输入$8a$，输出$7e$，即$7e=S(8a)$。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611194408448.png" alt="image-20210611194408448" style="zoom:80%;" />

**逆字节替代变换**是字节替代变换的逆变换，在状态的每个字节上应用逆S盒。这是通过应用**字节替代变换中的仿射变换的逆变换**，再对所得结果应用**有限域的乘法逆运算**得到的，即 $y=A^{-1}(x-B)$

逆S盒的使用：输入$7e$，输出$8a$

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611194647148.png" alt="image-20210611194647148" style="zoom:80%;" />

字节代换示意图：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611194704011.png" alt="image-20210611194704011" style="zoom:60%;" />

#### 行移位

将状态阵列的各行进行**循环移位**，**不同的行的移位量不同**。

0行：不动；

1行：循环左移$C_1$字节；

2行：循环左移$C_2$字节；

3行：循环左移$C_3$字节

行移位示意图（分组长度192 bit）：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611195037863.png" alt="image-20210611195037863" style="zoom:60%;" />

#### 列混淆

将每列视为$GF(2^8)$上的多项式，与固定的多项式$c(x)$进行模$x^4+1$乘法，记为$\bigotimes$，要求$c(x)$模$x^4+1$可逆。
$$
c(x)='03'x^3+'01'x^2+'01'x+'02'
$$
列混淆的矩阵表示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611195722107.png" alt="image-20210611195722107" style="zoom:50%;" />

列混淆示意图：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611195738511.png" alt="image-20210611195738511" style="zoom:60%;" />

逆列混淆变换是列混淆变换的逆。

它将状态矩阵中的每一列视为系数在$GF(2^8)$上的次数小于4的多项式与同一个固定的多项式$d(x)$相乘。$d(x)$满足$('03'x^3+'01'x^2+'01'x+'02')\bigotimes d(x)='01'$，由此可得
$$
d(x)='0B'x^3+'0D'x^2+'09'x+'0E'
$$
逆列混淆的矩阵表示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611200029794.png" alt="image-20210611200029794" style="zoom:50%;" />

#### 轮密钥加

**轮密钥与状态进行逐比特异或**，由种子密钥通过密钥编排算法得到。轮密钥长度与分组长度相同。

### 密钥编排

密钥编排指从种子密钥得到轮密钥的过程，它由**密钥扩展和轮密钥选取**两部分组成。其基本原则如下：
 （1）轮密钥的比特数等于分组长度乘以轮数加1；例如将128比特的明文经过10轮的加密，则总共需要$(10+1)\times 128=1408$比特的密钥；
 （2）种子密钥被扩展成为扩展密钥；
 （3）轮密钥从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前$N_b$个字，第2轮轮密钥取接下来的$N_b$个字，如此下去。

密钥扩展：扩展密钥是以4字节字为元素的一维阵列，表示为$W[N_b\times(N_r+1)]$，其中前$N_k$个字取为种子密钥，以后每个字按递归方式定义。扩展算法根据$N_k≤6$和$N_k>6$有所不同。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611200430210.png" alt="image-20210611200430210" style="zoom:50%;" />

- $N_k≤6$的情况下的算法(`RotByte`为字循环移位，`SubByte`为S盒变换，`Rcon`为轮常数)

```
KeyExpansion(byte Key[4*Nk],W[Nb*(Nr+1)])
{
	for(i=0;i<Nk;i++)
		W[i]=(Key[4*i],Key[4*i+1],Key[4*i+2],Key[4*i+3]);
	for(i=Nk;i<Nb*(Nr+1);i++)
	{
		temp=W[i-1];
		if(i%Nk==0)
			temp=SubByte(RotByte(temp))^Rcon[i/Nk];
		W[i]=W[i-Nk]^temp;
	}
}
```

当$N_k=4$时，

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611200842071.png" alt="image-20210611200842071" style="zoom:50%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611200854393.png" alt="image-20210611200854393" style="zoom:50%;" />

- $N_k>6$的情况下的算法(`RotByte`为字循环移位，`SubByte`为S盒变换，`Rcon`为轮常数)

```
KeyExpansion(byte Key[4*Nk],W[Nb*(Nr+1)])
{
	for(i=0;i<Nk;i++)
		W[i]=(Key[4*i],Key[4*i+1],Key[4*i+2],Key[4*i+3]);
	for(i=Nk;i<Nb*(Nr+1);i++)
	{
		temp=W[i-1];
		if(i%Nk==0)
			temp=SubByte(RotByte(temp))^Rcon[i/Nk];
		else if(i%Nk==4)
			temp=SubByte(temp);
		W[i]=W[i-Nk]^temp;
	}
}
```

两者区别在于当$i-4$为$N_k$的整数倍时，须先将前一个字$W[i-1]$经过`SubByte`变换。

轮密钥选取：轮密钥$i$由轮密钥缓冲字$W(N_b\times i)$到$W(N_b\times (i+1))$给出。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611201305254.png" alt="image-20210611201305254" style="zoom:50%;" />

## ch5 RSA加密算法

### 公钥加密体制

公钥加密体制解决了对称加密体制的**密钥管理问题**，将密钥数量由$O(n^2)$减少为$O(n)$。

### RSA公钥加密体制原理

**密钥生成**：
（1）选取两个大素数$p$，$q$
（2）计算$n=pq$，$z=(p-1)(q-1)$。（$z$为$n$的欧拉函数）
（3）随机选取$e$（其中$e<n$），$e$与$n$互素
（4）计算$d$，使得$ed-1$能够被$z$整除，即$ed\ mod\ z=1$
（5）公钥是$(n,e)$，私钥是$(n,d)$。

**加解密算法**：

（1）加密：由$c=m^e\ mod\ n$将明文$m$转变为密文$c$（$m^e$除以$n$所得的余数），其中$m<n$

（2）解密：$m=c^d\ mod\ n$（$c^d$除以$n$所得的余数）

**核心思想**：$m=(m^e\ mod\ n)^d\ mod\ n$

### 模重复平方法

在模重复计算中，常常要对大整数$m$和$n$，计算$b^n\ (mod\ m)$。如果用递归，则可以得到：
$$
b^n\ (mod\ m)=b^n\%m=b\times b^{(n-1)}\%m
$$
根据模的运算规则，可以进一步得到：
$$
b\times n^{n-1}≡b\times (b^{n-1}\ (mod\ m))\ (mod\ m)
$$
所以有：$b^n≡b\times(b^{n-1}\ (mod\ m))\ (mod\ m)$

得到$b^n\ (mod\ m)$的递归公式为：
$$
func(b,n,m)=b\times func(b,n-1,m)\%m
$$
模重复计算法的递归实现，思路简单清晰，但是因为递归层次过深，同时需要执行$n-1$次乘法，所以很难用于实际应用之中。 

一般我们会使用模重复平方法来实现（时间复杂度$O(logn)$）

**具体步骤**

（0）令$a=1$，并将$n$写成二进制$n=n_0+n_12+\dots+n_{k-1}2^{k-1}$。其中，$n_i\in\{0,1\},i=0,1,\dots k-1$

（1）如果$n_0=1$，则计算$a_0≡a\cdot b\ (mod\ m)$，否则取$a_0=a$，即计算$a_0≡a\cdot b^{n_0}\ (mod\ m)$，再计算$b_1≡b^2\ (mod\ m)$

（2）如果$n_1=1$，则计算$a_1≡a_0\cdot b_1\ (mod\ m)$，否则取$a_1=a_0$，即计算$a_1≡a_0\cdot b_1^{n_1}\ (mod\ m)$，再计算$b_2≡b_1^2\ (mod\ m)$

$\dots\dots$

（k-1）如果$n_{k-2}=1$，则计算$a_{k-2}≡a_{k-3}\cdot b_{k-2}\ (mod\ m)$，否则取$a_{k-2}=a_{k-3}$，即计算$a_{k-2}≡a_{k-3}\cdot b_{k-2}^{n_{k-2}}\ (mod\ m)$，再计算$b_{k-1}≡b_{k-2}^2\ (mod\ m)$

（k）如果$n_{k-1}=1$，则计算$a_{k-1}≡a+{k-2}\cdot b_{k-1}\ (mod\ m)$，否则取$a_{k-1}=a_{k-2}$，即计算$a_{k-1}≡a_{k-2}\cdot b_{k-1}^{n_{k-1}}\ (mod\ m)$，最后$a^{k-1}$就是$b^n\ (mod\ m)$。

## ch6 椭圆曲线密码

### 实数域上的椭圆曲线

曲线方程一般记作：$y^2=x^3+ax+b$

当$4a^3+27b^2\ne0$时，称椭圆曲线$E(a,b)$是一条非奇异椭圆曲线，可以基于集合$E(a,b)$定义一个Abel群。

**Abel群的加法规则**：

（1）无穷远点$O$为加法的单位元，对于椭圆曲线上的任何一点$P$， 有$P+O=P$
（2）对于椭圆曲线上的一点$P=(x,y)$，它的逆元为$-P=(x,-y)$。注意到$P+(-P)=P-P=O$ 
（3）设$P$和$Q$是椭圆曲线上$x$坐标不同的两点，$P+Q$定义如下：作一条通过$P$和$Q$的直线与椭圆曲线相交于$R$，然后过$R$点作$y$轴的平行线 ,其与椭圆曲线相交的另一点$S$就是$P+Q$，如下图所示：
<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210611210522272.png" alt="image-20210611210522272" style="zoom:50%;" />
（4）上述几何解释也适用于具有相同x坐标的两个点$P$和$-P$的情形。用一条垂直的线连接这两个点，可看作是在无穷远点与椭圆曲线相交，因此有$P+(-P)=O$。这与上述第（2）条叙述一致。 
（5）为计算点$Q$的两倍，在$Q$点作一条切线并找到与椭圆曲线的另一个交点$T$，则$Q+Q=2Q=-T$

对于椭圆曲线上互不为负元的两点$P=(x_1,y_1)$和$Q=(x_2,y_2)$，$S=P+Q=(x_3,y_3)$由以下规则确定：
$$
x_3=\lambda^2-x_1-x_2\\y_3=\lambda(x_1-x_3)-y_1
$$
式中，
$$
\lambda=\left\{\begin{align}\frac{y_2-y_1}{x_2-x_1}\ (P\ne Q)\\\frac{3x_1^2+a}{2y_1}\ (P=Q)\end{align}\right.
$$

### 有限域上的椭圆曲线

有限域$GF(p)$上的椭圆曲线是指满足方程$y^2≡x^3+ax+b\ (mod\ p)$的所有点$(x,y)$再加上一个无穷远点0构成的集合，其中，$a,b,x,y$均为有限域$GF(p)$中元素，$p$时素数。这里把该椭圆曲线记为$E_p(a,b)$。该椭圆曲线只有有限个点，Hasse定理给出了N的一个上界和一个下界。

**Hasse定理**：设$E$是有限域$GF(p)$上的椭圆曲线，$N$是$E$上点的个数，则$p+1-2\sqrt{p}\le N\le p+1+2\sqrt{p}$。当$4a^3+27b^2\ (mod\ p)\ne0$时，基于集合$E_p(a,b)$可以定义一个Abel群，其加法规则与实数域上描述的代数方法一致。设$P,Q\in E_p(a,b)$，则

（1）$P+0=P$

（2）如果$P=(x,y)$，那么$(x,y)+(x,-y)=0$，即点$(x,-y)$是$P$的加法逆元，表示为$-P$

（3）设$P=(x_1,y_1)$和$Q=(x_2,y_2)$，$P\ne -Q$，则$S=P+Q=(x_3,y_3)$

由以下规则确定：
$$
x_3≡\lambda^2-x_1-x_2\ (mod\ p)\\y_3≡\lambda(x_1-x_3)-y_1\ (mod\ p)
$$
式中，
$$
\lambda=\left\{\begin{align}\frac{y_2-y_1}{x_2-x_1}\ (mod\ p)\ (P\ne Q)\\\frac{3x_1^2+a}{2y_1}\ (mod\ p)\ (P=Q)\end{align}\right.
$$
（4）倍点运算定义为重复加法：如$4P=P+P+P+P$

例：设椭圆曲线方程为$y^2≡x^3+x+6\ (mod\ 11)$，对于每个$x\in GF(11)$，首先计算$z≡x^3+x+6\ (mod\ 11)$，然后再判定$z$是否是模11的平方剩余，若不是，则椭圆曲线上没有与这一$x$相对应的点；若是，求出$z$的两个平方根。该椭圆曲线上的点如下表所示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612104059143.png" alt="image-20210612104059143" style="zoom:50%;" />

可以得出，只有$x=2,3,5,7,8,10$时才有点在椭圆曲线上，$E_{11}(1,6)$是由表中的点再加上一个无穷远点0构成，即
$$
E_{11}(1,6)=\{O,(2,4),(2,7),(3,5),(3,6),(5,2),(5,9),(7,2),(7,9),(8,3),(8,8),(10,2),(10,9)\}
$$
设$P=(2,7)$，计算$2P=P+P$，首先计算
$$
\lambda≡\frac{3\times2^2+1}{2\times7}\ (mod\ 11)≡8\ (mod\ 11)
$$
于是，$x_3≡8^2-2-2\ (mod\ 11)≡5\ (mod\ 11)$，$y_3≡8(2-5)-7≡2\ (mod\ 11)$

所以$2P=(5,2)$同样可以算出$3P=(8,3)$，$4P=(10,2)$，$5P=(3,6)$，$6P=(7,9)$，$7P=(7,2)$，$8P=(3,5)$，$9P=(10,9)$，$10P=(8,8)$，$11P=(5,9)$，$12P=(2,4)$，$13P=O$

由此看出，$E_{11}(1,6)$是一个循环群，其生成元是$P=(2,7)$

### 椭圆曲线上的El Gamal方案

定义1：椭圆曲线$E_p(a,b)$上的点$P$的阶是指满足$nP=P+P+\dots+P=O$的最小正整数，记为$ord(P)$，其中$O$是无穷远点。

定义2：设$G$是椭圆曲线$E_p(a,b)$上的一个循环子群，$P$是$G$的一个生成元，$Q∈G$。已知$P$和$Q$，求满足$mP=Q$的整数$m$，$0\le m\le ord(P)-1$，称为椭圆曲线上的离散对数问题(ECDLP)。计算$mP$的过程称为点乘运算。

#### 算法流程

（1）密钥生成：在椭圆曲线$E_p(a,b)$上选取一个阶为$n$（$n$为一个大素数）的生成元$P$。随机选取整数$x$（$1<x<n$），计算$Q=xP$。公钥为$Q$，私钥为$x$。

（2）加密：为了加密$P_m$，随机选取一个整数$k$，$1<k<n$，计算$C_1=kP$，$C_2=P_m+kQ$，则密文$c=(C_1,C_2)$

（3）解密：为了解密一个密文$c=(C_1,C_2)$，计算攻击者要想从$c=(C_1,C_2)$计算出$P_m$，就必须要知道$k$。从而要从$P$和$kP$中计算出$k$将面临求解椭圆曲线上的离散对数问题。

## ch7 哈希函数

### 概念

哈希函数又称杂凑函数、Hash函数、消息摘要函数等。其目的是将任意长度的消息$m$压缩成指定长度的数据$H(m)$，其中$H(m)$又称为$m$的摘要或指纹。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612112127439.png" alt="image-20210612112127439" style="zoom:50%;" />

哈希函数的应用：**完整性认证**、**数字签名**

哈希函数应满足的条件：

- $H$能够应用到任何大小的数据块上；
- $H$能够生成大小固定的输出；
- 对任意给定的$m$，$H(m)$的计算相对简单，使得硬件和软件的实现可行。
- 单向性（第一原像不可求），对于任意的$h$，要发现满足$H(m)=h$的$m$是计算上不可行的；
- 弱抗碰撞性，对于任意给定的$m_1$，要找到满足$H(m_2)=H(m_1)$，且$m_2\ne m_1$的$m_2$，是计算上不可行的。
- 强抗碰撞性，要发现满足$H(m_1)=H(m_2)$，而$m_1\ne m_2$的对$(m_1,m_2)$是计算上不可行的。

优点：任何人都可对消息的“指纹”进行检验。

缺点：掌握消息的人都可生成报文的“指纹”。

### 基本攻击方法

#### 碰撞攻击

目的：构造报文$m_1$和$m_2$使得$H(m_1)=H(m_2)$

生日悖论：23个人中至少有两个人生日相同的概率超过$\frac{1}{2}$。

算法：
（1）随机选取$N$个报文$m_1,m_2, … , m_N$; 
（2）以这$N$个报文作为杂凑函数的输入，计算出相应的杂凑值，得到集合$S=\{(m_k, H(mk))|k = 1,2, … N\}$；
（3）根据$𝐻(𝑚𝑘)$的大小，对集合$S$利用快速排序算法重新排序：在排序过程中，如果找到了$𝐻(𝑚_𝑘)=𝐻(𝑚_𝑡)$的两个不同元素$m_k$和$m_t$，就将$(m_k, m_t)$作为结果输出，算法中止；如果找不到，就报告碰撞攻击失败，算法中止。

### MD5哈希算法

MD5特点：对任意长度的输入，都能产生128位的输出；其安全性不依赖于任何假设，适合高速实现。

#### MD5算法

①初始化处理：消息填充。目的是使MD填充后的消息长度是512的整数倍。

方法：设原始消息$x$的长度是$L$比特。 

（1）求出$𝑑 ≥ 0$，使得$𝐿 + 1 + 𝑑 + 64$是512的整数倍；

（2）在原始报文$𝑥$后面添加一个1，然后添加$𝑑$个0，最后将消息的长度$𝐿$用64比特表示，加在最后。

填充后的报文=$x||1||0^d||𝐿$ 

由$𝐿 + 1 + 𝑑 + 64 ≡ 0\ 𝑚𝑜𝑑\ 512$得，$𝑑 = − 𝐿 + 65\ 𝑚𝑜𝑑\ 512$

例：设$x$是具有20768比特的长信息，则: 

```
d = −(L+65) mod 512
= −(20768+65) mod 512
= −20833mod 512
= −(40×512+353) mod 512
= −353 mod 512
= 159
```

故应在$x$后面添加1个1和159个0，最后再添加原始消息长度20768的64位表示。

MD5算法的输入消息$x$被分成512比特的消息块$x_1, x_2, … , x_t$，$t$的取值是填充后消息的512比特分组的数目。然后将每个消息块划分成16个32比特的子块，记为$M = M_0M_1… M_{15}$，其中$|M|= 512$，$|M_i| = 32,i = 0,1, … , 15$。

②初始向量：4个32比特的初始向量：A=0x01234567、B=0x89abcdef、C=0xfedcba98、D=0x76543210

③基本运算：算法主循环用到的四个基本函数为：$f(X,Y,Z)=(X\wedge Y\vee(\overline{X}\wedge Z))$、$g(X,Y,Z)=(X\wedge Z)\vee(Y\wedge\overline{Z})$、$h(X,Y,Z)=X\oplus Y\oplus Z$、$l(X,Y,Z)=Y\oplus(X\vee\overline{Z})$，其中，$x\wedge y$表示逐位与运算，$x\oplus y$表示逐位模2加运算，$x\vee y$表示逐位或运算，$\overline{x}$表示逐位取补运算，$x+y$表示模$2^{32}$位加运算，$x<<<s$表示循环左移s位。

#### 轮函数

模型：$H_i=h(H_{i-1},M_i)\oplus H_{i-1}$，其中$H_{i-1}=(A,B,C,D)$，h由round1，round2，round3和round4组成。

具体过程：对$i=0,\dots,N/16-1$，依次执行以下步骤：（N/16是512比特块的个数）

Step1	令$X[0]=M[16i],X[1]=M[16i]+1,…,X[15]=M[16i+15]$；
Step2 	令$AA=A,BB=B,CC=C,DD=D$；
Step3 	执行$( 𝐴, 𝐵, 𝐶,𝐷) = 𝑟𝑜𝑢𝑛𝑑1(𝐴, 𝐵, 𝐶,𝐷, 𝑋 0 , … , 𝑋[15])$;
Step4 	执行$( 𝐴, 𝐵, 𝐶,𝐷) = 𝑟𝑜𝑢𝑛𝑑2(𝐴, 𝐵, 𝐶,𝐷, 𝑋 0 , … , 𝑋[15])$;
Step5 	执行$( 𝐴, 𝐵, 𝐶,𝐷) = 𝑟𝑜𝑢𝑛𝑑3(𝐴, 𝐵, 𝐶,𝐷, 𝑋 0 , … , 𝑋[15])$;
Step6 	执行$( 𝐴, 𝐵, 𝐶,𝐷) = 𝑟𝑜𝑢𝑛𝑑4(𝐴, 𝐵, 𝐶,𝐷, 𝑋 0 , … , 𝑋[15])$;
Step7 	$𝐴 = 𝐴 + 𝐴𝐴, 𝐵 = 𝐵 + 𝐵𝐵, 𝐶 = 𝐶 + 𝐶𝐶,𝐷 = 𝐷 + 𝐷𝐷$；
最后输出128比特散列值：$𝑀𝐷5(X) = 𝐴|| 𝐵|| 𝐶||𝐷$

round1~round4的描述见下图：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612144139999.png" alt="image-20210612144139999" style="zoom:50%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612144149929.png" alt="image-20210612144149929" style="zoom:50%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612144157609.png" alt="image-20210612144157609" style="zoom:50%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612144205459.png" alt="image-20210612144205459" style="zoom:50%;" />

## ch8 数字签名

### 基本原理

数据摘要：首先使用**某种散列算法**，对要发送的数据进行处理，生成数据摘要信息；然后采用**公钥密码算法**，用**私钥加密数据摘要**信息。

一个签名体制一般包括两个部分。一是**发送方的签名部分**，对消息$M$签名，可以记作$S=Sig(K,M)$；二是**接收方的认证部分**，对签名S的验证可以记作$Ver(M,S,K)——\{真，假\}$.

**特点**：
（1）信息是由**签名者**发送的；
（2）信息自签发后到收到为止**未曾做过任何修改**；
（3）如果A否认对信息的签名，**可以通过仲裁**解决A和B之间的争议；
（4）数字签名不同于手写签名：数字签名随文本的变化而变化，手写签字反应某个人个性特征，是不变的；数字签名与文本信息是不可分割的，而用手写签字是附加在文本之后的，与文本信息是分离的。

形式化定义：一个签名方案由签署算法与验证算法两部分构成，可用五元关系组$(P,A,K,S,y)$表示，其中，P是由一切可能消息所构成的有限集合；A是一切可能的签名的有限集合；K为有限密钥空间，是一些可能密钥的有限集合；任意$k∈K$，有签署算法$Sigk∈S$，$Sigk：P→ A$，对任意$x∈P$，有$s=Sigk(x)$，那么$s∈S$为消息$x$的签名，将$(x,s)$发送到签名验证者。对于密钥集合$K$有对应的验证算法$Verk∈y$，满足：$P\times A\to\{真，假\}$。

签名者收到$(x,s)$后，计算$Verk(x,y)$，若$y=Sigk(x)$，则$Verk(x,y)$为真；若$y≠Sigk(x)$，则$Verk(x,y)$为假。其中：
①任意$k∈K$，函数$Sigk$和$Verk$都为多项式时间函数。
②$Verk$为公开的函数，而$Sigk$为秘密函数。
③如果坏人要伪造$B$对$x$的签名，再计算上不可能的。也即，给定$x$，仅有$B$能计算出签名$y$，使得$Verk(x,y)=真$。
④一个签名方案不能是无条件安全的，有足够的时间，第三方总能伪造$B$的签名。

**功能**：身份认证、保密、完整性、不可抵赖

**分类**：基于数学难题（离散对数、素因子分解、两种结合）、基于签名用户（单用户、多用户）、基于数字签名所具有特性（是否具有消息自动恢复能力）、基于数字签名所涉及的通信角色（直接、需仲裁）

**使用模式**：智慧卡式、密码式、生物测定式

**原理**：数字签名使用的是发送方的密钥对，发送方用自己的私有密钥进行加密，接收方用发送方的公开密钥进行解密。
这是一个一对多的关系：任何拥有发送方公开密钥的人都可以验证数字签名的正确性。而私有密钥的加密解密则使用的是接收方的密钥对，这是多对一的关系：任何知道接收方公开密钥的人都可以向接收方发送加密消息，只有唯一拥有接受方私有密钥的人才可以对信息解密。
通常一个用户拥有两个密钥对，一个密钥对用来对数字签名进行加密解密，另一个密钥对对私有密钥进行加密解密。这种方式提供了更高的安全性。

**利用散列函数进行数字签名和验证的文件传输过程**：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612150046707.png" alt="image-20210612150046707" style="zoom: 40%;" />

### RSA数字签名

数字签名过程：

（1）计算消息的散列值$H(M)$；

（2）用私钥$(d,n)$加密散列值：$s=(H(M))^d\ mod\ n，签名结果就是$s$；

（3）发送消息和签名$(M,s)$。当然，消息$M$很短的时候，可以直接对$M$用私钥加密，可表达为：$s=Sig(M)=M^d\ mod\ n$，签名时使用私钥$(d,n)$。

认证过程：

接收方收到$(M,s)$之后：

（1）取得发送方的公钥$(e,n)$；

（2）解密签名$s: h=s^e\ mod\ n$；

（3）计算消息的散列值$H(M)$；

（4）比较，如果$h=H(M)$，表示签名有效；否则，签名无效。

如果消息$M$很短的时候，可以直接对$M$用公钥解密以验证签名的有效性，可以表达为$Ver(M,s)=真<=>M=s^e\ mod\ n$

### DSS数字签名

算法流程：

（1）DSA算法参数说明：

DSA算法中应用了下述参数：
$P$：L bit长的素数。L是64的倍数，范围是512-1024；
$Q$：能被$P-1$整除的160 bit的素数
$G$：$g=h^{(p-1)/q}\ mod\ p$，$1< h < p - 1$，$g > 1$；
$X$：$x < q$，$x$为私钥；
$Y$：$y = g^x\ mod\ p$ ，$(p, q, g, y)$为公钥；
其中，$p$，$q$，$g$以及公钥$y$，私钥$x$必须保密，任何第三方用户想要从$Y$解密成$X$都必须解决整数有限域离散对数难题。

（2）签名：

$P$产生随机数$k$，$k < q$；

$P$计算$r = ( g^k\ mod\ p )\ mod\ q$，$s = ( k^{-1} (H(m) + xr))\ mod\ q$

签名结果是$( m, r, s )$。$H(m)$是单向Hash函数。

（3）验证：

$w = s^{-1}\ mod\ q$

$u_1 = ( H( m ) \times w )\ mod\ q$

$u_2 = ( r \times w )\ mod\ q$

$v = (( g^{u_1} \times y^{u_2} )\ mod\ p )\ mod\ q$

若$v = r$，则认为签名有效。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210612152142179.png" alt="image-20210612152142179" style="zoom:67%;" />

特点：两个素数公开，这样当别人使用$p$和$q$时，即使不知道私钥，也能确认它们是否是随机产生的，而RSA签名算法做不到。
